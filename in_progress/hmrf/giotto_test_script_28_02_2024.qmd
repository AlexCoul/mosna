---
title: "HMRF_R_CODEX_spleen_2018"
format: html
editor: visual
---

## Quarto

Quarto enables you to weave together content and executable code into a finished document. To learn more about Quarto see <https://quarto.org>.

```{r}
# Code Block 1 - Ensure Installation Correct

# Ensure Giotto Suite is installed.
if(!"Giotto" %in% installed.packages()) {
  devtools::install_github("drieslab/Giotto@suite")
}

# Ensure GiottoData, a small, helper module for tutorials, is installed.
if(!"GiottoData" %in% installed.packages()) {
  devtools::install_github("drieslab/GiottoData")
}
library(Giotto)
# Ensure the Python environment for Giotto has been installed.
genv_exists = checkGiottoEnvironment()
if(!genv_exists){
  # The following command need only be run once to install the Giotto environment.
  installGiottoEnvironment()
}
```

```{r}
# Code Block 2 - Set Paths

library(Giotto)
library(GiottoData)

# 1. set working directory
results_folder = '../output/CODEX_spleen_2018/'


# Optional: Specify a path to a Python executable within a conda or miniconda
# environment. If set to NULL (default), the Python executable within the previously
# installed Giotto environment will be used.
my_python_path = "/usr/bin/python3"
```

```{r}
# Code Block 3 - Download CODEX spleen 2018 data set

# download data to working directory
# use method = 'wget' if wget is available. This should be much faster.
# if you run into authentication issues with wget, then add " extra = '--no-check-certificate' "
getSpatialDataset(dataset = 'codex_spleen', directory = results_folder, method = 'wget')
```

```{r}
# Code Block 4

# 1. (optional) set Giotto instructions
instrs = createGiottoInstructions(show_plot = TRUE,
                                  save_plot = TRUE,
                                  save_dir = results_folder,
                                  python_path = my_python_path)

# 2. create giotto object from provided paths ####
expr_path = paste0(results_folder, "codex_BALBc_3_expression.txt.gz")
loc_path = paste0(results_folder, "codex_BALBc_3_coord.txt")
meta_path = paste0(results_folder, "codex_BALBc_3_annotation.txt")
```

```{r}
# Code Block 5 - Read in data and create visualization to check if succesful

# read in data information

# expression info
codex_expression = readExprMatrix(expr_path, transpose = F)
# cell coordinate info
codex_locations = data.table::fread(loc_path)
# metadata
codex_metadata = data.table::fread(meta_path)



## stitch x.y tile coordinates to global coordinates
xtilespan = 1344;
ytilespan = 1008;
# TODO: expand the documentation and input format of stitchTileCoordinates. Probably not enough information for new users.
stitch_file = stitchTileCoordinates(location_file = codex_metadata,
                                    Xtilespan = xtilespan,
                                    Ytilespan = ytilespan)
codex_locations = stitch_file[,.(Xcoord, Ycoord)]

# create Giotto object
codex_test <- createGiottoObject(expression = codex_expression,
                                 spatial_locs = codex_locations,
                                 instructions = instrs)
codex_metadata$cell_ID<- as.character(codex_metadata$cellID)
codex_test<-addCellMetadata(codex_test, new_metadata = codex_metadata,
                           by_column = T,
                           column_cell_ID = "cell_ID")
# subset Giotto object
cell_meta = pDataDT(codex_test)
cell_IDs_to_keep = cell_meta[Imaging_phenotype_cell_type != "dirt" & Imaging_phenotype_cell_type != "noid" & Imaging_phenotype_cell_type != "capsule",]$cell_ID
codex_test = subsetGiotto(codex_test,
                          cell_ids = cell_IDs_to_keep)

## filter
codex_test <- filterGiotto(gobject = codex_test,
                           expression_threshold = 1,
                           feat_det_in_min_cells = 10,
                           min_det_feats_per_cell = 2,
                           expression_values = c('raw'),
                           verbose = T)

codex_test <- normalizeGiotto(gobject = codex_test,
                              scalefactor = 6000,
                              verbose = T,
                              log_norm = FALSE,
                              library_size_norm = FALSE,
                              scale_feats = FALSE,
                              scale_cells = TRUE)

## add gene & cell statistics
codex_test <- addStatistics(gobject = codex_test,expression_values = "normalized")

## adjust expression matrix for technical or known variables
codex_test <- adjustGiottoMatrix(gobject = codex_test,
                                 expression_values = c('normalized'),
                                 batch_columns = 'sample_Xtile_Ytile',
                                 covariate_columns = NULL,
                                 return_gobject = TRUE,
                                 update_slot = c('custom'))

## visualize
spatPlot(gobject = codex_test,point_size = 0.1,
         coord_fix_ratio = NULL,point_shape = 'no_border',
         save_param = list(save_name = '2_a_spatPlot'))
```

```{r}
# Code Block 6 - Create Visualization of different regions

spatPlot(gobject = codex_test,
         point_size = 0.2,
         coord_fix_ratio = 1,
         cell_color = 'sample_Xtile_Ytile',
         legend_symbol_size = 3,
         legend_text = 5,
         save_param = list(save_name = '2_b_spatPlot'))
```

```{r}
# In order to make Block 7 work, we needed to run the following installation:
#install.packages(c("FactoMineR"))
```

```{r}
# Code Block 7 - Dimension Reduction with PCA

# use all Abs

# PCA
codex_test <- runPCA(gobject = codex_test,
                     expression_values = 'normalized',
                     scale_unit = T,
                     method = "factominer")
signPCA(codex_test,
        scale_unit = T,
        scree_ylim = c(0, 3),
        save_param = list(save_name = '3_a_spatPlot'))
```

```{r}
# Code Block 8 - Show PCA

plotPCA(gobject = codex_test,
        point_shape = 'no_border',
        point_size = 0.2,
        save_param = list(save_name = '3_b_PCA'))
```

```{r}
# Code Block 9

# UMAP
codex_test <- runUMAP(codex_test,
                      dimensions_to_use = 1:14,
                      n_components = 2,
                      n_threads = 12)
plotUMAP(gobject = codex_test,
         point_shape = 'no_border',
         point_size = 0.2,
         save_param = list(save_name = '3_c_UMAP'))


```

```{r}
# Code Block 10 - Create network and perform clustering with Leiden method

## sNN network (default)
codex_test <- createNearestNetwork(gobject = codex_test,
                                   dimensions_to_use = 1:14,
                                   k = 20)

## 0.1 resolution
codex_test <- doLeidenCluster(gobject = codex_test,
                              resolution = 0.5,
                              n_iterations = 100,
                              name = 'leiden')

codex_metadata = pDataDT(codex_test)
leiden_colors = Giotto:::getDistinctColors(length(unique(codex_metadata$leiden)))
names(leiden_colors) = unique(codex_metadata$leiden)

plotUMAP(gobject = codex_test,
         cell_color = 'leiden',
         point_shape = 'no_border',
         point_size = 0.2,
         cell_color_code = leiden_colors,
         save_param = list(save_name = '4_a_UMAP'))
```

```{r}
# Code Block 11 - Show spatial map of clustering (Leiden)

spatPlot(gobject = codex_test,
         cell_color = 'leiden',
         point_shape = 'no_border',
         point_size = 0.2,
         cell_color_code = leiden_colors,
         coord_fix_ratio = 1,
         label_size =2,
         legend_text = 5,
         legend_symbol_size = 2,
         save_param = list(save_name = '4_b_spatplot'))
```

```{r}
# Show both in single figure (Co-visualize)

spatDimPlot2D(gobject = codex_test,
              cell_color = 'leiden',
              spat_point_shape = 'no_border',
              spat_point_size = 0.2,
              dim_point_shape = 'no_border',
              dim_point_size = 0.2,
              cell_color_code = leiden_colors,
              plot_alignment = c("horizontal"),
              save_param = list(save_name = '5_a_spatdimplot'))
```
